<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real UPC Lookup Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .result { margin: 10px 0; padding: 10px; border-radius: 3px; }
        .success { background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .error { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        .warning { background-color: #fff3cd; border: 1px solid #ffeaa7; color: #856404; }
        .info { background-color: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460; }
        button { padding: 10px 15px; margin: 5px; cursor: pointer; }
        input { padding: 8px; margin: 5px; width: 200px; }
        .log { background: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; margin: 10px 0; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; }
    </style>
</head>
<body>
    <h1>üîç Real UPC Lookup Test</h1>
    <p>This page tests the actual UPC scanner functionality with real lookups.</p>
    
    <div class="test-section">
        <h2>üì± Camera Scanner</h2>
        <p>Use your device's camera to scan a UPC barcode:</p>
        <button id="startScanBtn">Start Camera Scanner</button>
        <button id="stopScanBtn" disabled>Stop Scanner</button>
        <div id="scannerStatus"></div>
        <div id="scanResults"></div>
    </div>

    <div class="test-section">
        <h2>üîç Manual UPC Entry</h2>
        <p>Or manually enter a UPC to test:</p>
        <input type="text" id="manualUPC" placeholder="Enter UPC (e.g., 715515315616)" maxlength="13">
        <button id="lookupBtn">Lookup UPC</button>
        <div id="manualResults"></div>
    </div>

    <div class="test-section">
        <h2>üìä Test Results</h2>
        <div id="testResults"></div>
    </div>

    <div class="test-section">
        <h2>üìù Console Log</h2>
        <div id="consoleLog" class="log"></div>
        <button id="clearLogBtn">Clear Log</button>
    </div>

    <!-- Include ZXing library for barcode scanning -->
    <script src="https://unpkg.com/@zxing/library@latest/umd/index.min.js"></script>
    
    <script>
        // Copy the real functions from scanner-new.js
        function isValidTitle(title) {
            if (!title || title.length < 5 || title.length > 200) return false;
            
            // Reject titles that contain JavaScript code or HTML
            if (title.includes('<') || title.includes('>') || title.includes('{') || title.includes('}')) return false;
            if (title.includes('function') || title.includes('var ') || title.includes('google.')) return false;
            if (title.includes('script') || title.includes('onclick') || title.includes('onload')) return false;
            
            // Reject generic HTML and browser content
            if (title.toLowerCase().includes('doctype') || title.toLowerCase().includes('html')) return false;
            if (title.toLowerCase().includes('google search') || title.toLowerCase().includes('bing search')) return false;
            if (title.toLowerCase().includes('search results') || title.toLowerCase().includes('search engine')) return false;
            if (title.toLowerCase().includes('webpage') || title.toLowerCase().includes('page not found')) return false;
            
            // CRITICAL: Reject generic copyright and company names
            if (title.toLowerCase().includes('copyright') || title.toLowerCase().includes('llc')) return false;
            if (title.toLowerCase().includes('google') || title.toLowerCase().includes('bing')) return false;
            if (title.toLowerCase().includes('duckduckgo') || title.toLowerCase().includes('privacy')) return false;
            if (title.toLowerCase().includes('intelligent search') || title.toLowerCase().includes('makes it easier')) return false;
            
            // CRITICAL: Reject technical/component terms that are clearly not movie titles
            if (title.toLowerCase().includes('component') || title.toLowerCase().includes('state')) return false;
            if (title.toLowerCase().includes('invalid') || title.toLowerCase().includes('error')) return false;
            if (title.toLowerCase().includes('webfont') || title.toLowerCase().includes('font')) return false;
            if (title.toLowerCase().includes('rsontop') || title.toLowerCase().includes('wflare')) return false;
            
            // Reject titles that are just random characters or technical gibberish
            if (/^[A-Za-z0-9]{20,}$/.test(title)) return false;
            if (/^[A-Z][a-z]+[A-Z][a-z]+[A-Z][a-z]+/.test(title)) return false; // camelCase patterns
            
            // Reject titles that are just punctuation or numbers
            if (/^[^A-Za-z]*$/.test(title)) return false;
            
            // Must contain at least some letters
            if (!/[A-Za-z]/.test(title)) return false;
            
            // Must look like a movie title (not just generic text)
            if (title.length < 8) return false; // Too short to be a real movie title
            
            // Reject titles that are clearly not movie titles
            if (title.toLowerCase().includes('search') || title.toLowerCase().includes('browser')) return false;
            if (title.toLowerCase().includes('simplified') || title.toLowerCase().includes('quickly find')) return false;
            
            // CRITICAL: Must contain spaces or look like a real movie title
            if (!title.includes(' ') && title.length < 15) return false; // Single words are rarely movie titles
            
            return true;
        }

        function generateSmartTitle(upc, searchResults = []) {
            log('üîß Generating smart title for UPC:', upc);
            
            // Check if we have any valid search results first
            if (searchResults && searchResults.length > 0) {
                const bestResult = searchResults[0];
                if (bestResult && bestResult.title && isValidTitle(bestResult.title)) {
                    log('‚úÖ Using valid search result:', bestResult.title);
                    return bestResult.title;
                }
            }
            
            // Analyze UPC format to determine media type
            const upcStr = upc.toString();
            log('üîç Analyzing UPC format:', upcStr);
            
            let format = 'Unknown';
            let prefix = upcStr.substring(0, 1);
            
            // Common UPC patterns for movies
            const moviePatterns = {
                '0': 'DVD',
                '1': 'DVD', 
                '2': 'DVD',
                '3': 'DVD',
                '4': 'DVD',
                '5': 'DVD',
                '6': 'DVD',
                '7': 'DVD',
                '8': 'DVD',
                '9': 'DVD'
            };
            
            if (moviePatterns[prefix]) {
                format = moviePatterns[prefix];
                log('‚úÖ Detected format:', format, 'for prefix:', prefix);
            } else {
                log('‚ö†Ô∏è Unknown format for prefix:', prefix);
            }
            
            // Generate descriptive title
            const title = `Unknown ${format} Movie [UPC: ${upc}]`;
            log('üé¨ Generated title:', title);
            return title;
        }

        async function searchOnlineDatabases(upc) {
            log('üåê Searching public sources for UPC:', upc);
            
            const results = [];
            
            try {
                // Try Google search
                log('üîç Trying Google search...');
                const googleResult = await searchGoogle(upc);
                if (googleResult && googleResult.title) {
                    log('‚úÖ Google search successful:', googleResult.title);
                    results.push(googleResult);
                }
            } catch (error) {
                log('‚ùå Google search failed:', error.message);
            }
            
            try {
                // Try Bing search
                log('üîç Trying Bing search...');
                const bingResult = await searchBing(upc);
                if (bingResult && bingResult.title) {
                    log('‚úÖ Bing search successful:', bingResult.title);
                    results.push(bingResult);
                }
            } catch (error) {
                log('‚ùå Bing search failed:', error.message);
            }
            
            try {
                // Try DuckDuckGo search
                log('üîç Trying DuckDuckGo search...');
                const duckDuckGoResult = await searchDuckDuckGo(upc);
                if (duckDuckGoResult && duckDuckGoResult.title) {
                    log('‚úÖ DuckDuckGo search successful:', duckDuckGoResult.title);
                    results.push(duckDuckGoResult);
                }
            } catch (error) {
                log('‚ùå DuckDuckGo search failed:', error.message);
            }
            
            log('üîç Found', results.length, 'search results from search engines:', results);
            
            if (results.length === 0) {
                log('‚ùå No search results found');
                return null;
            }
            
            // Find the best result (highest score, then first valid title)
            let bestResult = results[0];
            for (const result of results) {
                if (result.score > bestResult.score) {
                    bestResult = result;
                }
            }
            
            // CRITICAL: Validate the title before returning
            if (bestResult && bestResult.title && isValidTitle(bestResult.title)) {
                log('‚úÖ Best result has valid title:', bestResult.title);
                return bestResult;
            } else {
                log('‚ùå Best result has poor quality title:', bestResult?.title);
                log('üí° Will use fallback title generation');
                return null;
            }
        }

        async function searchGoogle(upc) {
            const query = `${upc} movie dvd blu-ray`;
            const proxies = [
                `https://corsproxy.io/?https://www.google.com/search?q=${encodeURIComponent(query)}`,
                `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://www.google.com/search?q=${query}`)}`,
                `https://cors-anywhere.herokuapp.com/https://www.google.com/search?q=${encodeURIComponent(query)}`
            ];
            
            for (const proxy of proxies) {
                try {
                    log('üîç Trying proxy:', proxy);
                    const response = await fetch(proxy);
                    if (!response.ok) {
                        log('‚ùå Proxy failed:', response.status, response.statusText);
                        continue;
                    }
                    
                    const html = await response.text();
                    log('‚úÖ Google search successful via proxy');
                    
                    // Parse the HTML to extract title
                    const title = parseGoogleResults(html, upc);
                    if (title) {
                        return { title, score: 10, source: 'Google' };
                    }
                } catch (error) {
                    log('‚ùå Proxy error:', error.message);
                }
            }
            
            throw new Error('All Google search proxies failed');
        }

        async function searchBing(upc) {
            const query = `${upc} movie dvd blu-ray`;
            const proxies = [
                `https://corsproxy.io/?https://www.bing.com/search?q=${encodeURIComponent(query)}`,
                `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://www.bing.com/search?q=${query}`)}`,
                `https://cors-anywhere.herokuapp.com/https://www.bing.com/search?q=${encodeURIComponent(query)}`
            ];
            
            for (const proxy of proxies) {
                try {
                    log('üîç Trying proxy:', proxy);
                    const response = await fetch(proxy);
                    if (!response.ok) {
                        log('‚ùå Proxy failed:', response.status, response.statusText);
                        continue;
                    }
                    
                    const html = await response.text();
                    log('‚úÖ Bing search successful via proxy');
                    
                    // Parse the HTML to extract title
                    const title = parseBingResults(html, upc);
                    if (title) {
                        return { title, score: 8, source: 'Bing' };
                    }
                } catch (error) {
                    log('‚ùå Proxy error:', error.message);
                }
            }
            
            throw new Error('All Bing search proxies failed');
        }

        async function searchDuckDuckGo(upc) {
            const query = `${upc} movie dvd blu-ray`;
            const proxies = [
                `https://corsproxy.io/?https://duckduckgo.com/?q=${encodeURIComponent(query)}`,
                `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://duckduckgo.com/?q=${query}`)}`,
                `https://cors-anywhere.herokuapp.com/https://duckduckgo.com/search?q=${encodeURIComponent(query)}`
            ];
            
            for (const proxy of proxies) {
                try {
                    log('üîç Trying proxy:', proxy);
                    const response = await fetch(proxy);
                    if (!response.ok) {
                        log('‚ùå Proxy failed:', response.status, response.statusText);
                        continue;
                    }
                    
                    const html = await response.text();
                    log('‚úÖ DuckDuckGo search successful via proxy');
                    
                    // Parse the HTML to extract title
                    const title = parseDuckDuckGoResults(html, upc);
                    if (title) {
                        return { title, score: 6, source: 'DuckDuckGo' };
                    }
                } catch (error) {
                    log('‚ùå Proxy error:', error.message);
                }
            }
            
            throw new Error('All DuckDuckGo search proxies failed');
        }

        function parseGoogleResults(html, upc) {
            log('üîç Parsing Google results...');
            
            // Try to find title in meta tags first
            const titleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
            if (titleMatch) {
                const title = titleMatch[1].trim();
                log('‚úÖ Found Google title:', title);
                return title;
            }
            
            // Fallback: look for any text that might be a title
            const textMatch = html.match(/>([^<>]{10,50})</g);
            if (textMatch) {
                for (const match of textMatch) {
                    const text = match.replace(/[<>]/g, '').trim();
                    if (text.length > 10 && text.length < 50 && !text.includes('google') && !text.includes('search')) {
                        log('‚úÖ Found Google fallback title:', text);
                        return text;
                    }
                }
            }
            
            return null;
        }

        function parseBingResults(html, upc) {
            log('üîç Parsing Bing results...');
            
            // Try to find title in meta tags first
            const titleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
            if (titleMatch) {
                const title = titleMatch[1].trim();
                log('‚úÖ Found Bing title:', title);
                return title;
            }
            
            // Fallback: look for any text that might be a title
            const textMatch = html.match(/>([^<>]{10,50})</g);
            if (textMatch) {
                for (const match of textMatch) {
                    const text = match.replace(/[<>]/g, '').trim();
                    if (text.length > 10 && text.length < 50 && !text.includes('bing') && !text.includes('search')) {
                        log('‚úÖ Found Bing text title:', text);
                        return text;
                    }
                }
            }
            
            return null;
        }

        function parseDuckDuckGoResults(html, upc) {
            log('üîç Parsing DuckDuckGo results...');
            
            // Try to find title in meta tags first
            const titleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
            if (titleMatch) {
                const title = titleMatch[1].trim();
                log('‚úÖ Found DuckDuckGo title:', title);
                return title;
            }
            
            // Fallback: look for any text that might be a title
            const textMatch = html.match(/>([^<>]{10,50})</g);
            if (textMatch) {
                for (const match of textMatch) {
                    const text = match.replace(/[<>]/g, '').trim();
                    if (text.length > 10 && text.length < 50 && !text.includes('duckduckgo') && !text.includes('search')) {
                        log('‚úÖ Found DuckDuckGo fallback title:', text);
                        return text;
                    }
                }
            }
            
            return null;
        }

        async function lookupMovieByUPC(upc) {
            log('üîç Looking up movie for UPC:', upc);
            
            try {
                // Search online databases
                const movieData = await searchOnlineDatabases(upc);
                
                if (movieData && movieData.title && isValidTitle(movieData.title)) {
                    log('‚úÖ Found valid movie data online:', movieData);
                    return movieData;
                } else {
                    log('‚ùå No valid movie data found online, using fallback');
                }
            } catch (error) {
                log('‚ùå Online search failed:', error.message);
            }
            
            // Generate fallback title
            const fallbackTitle = generateSmartTitle(upc);
            log('üí° Using generated fallback title:', fallbackTitle);
            
            return {
                upc: upc,
                title: fallbackTitle,
                year: '',
                director: '',
                genre: '',
                runtime: '',
                formats: 'Unknown',
                image: '',
                added: new Date().toISOString()
            };
        }

        // Scanner functionality
        let codeReader = null;
        let videoElement = null;
        let isScanning = false;

        async function startScanner() {
            try {
                log('üì± Starting camera scanner...');
                
                if (!window.ZXing) {
                    throw new Error('ZXing library not loaded');
                }
                
                codeReader = new window.ZXing.BrowserMultiFormatReader();
                videoElement = document.createElement('video');
                videoElement.style.width = '100%';
                videoElement.style.maxWidth = '400px';
                
                document.getElementById('scannerStatus').innerHTML = '<p>Camera starting...</p>';
                document.getElementById('scanResults').appendChild(videoElement);
                
                await codeReader.decodeFromVideoDevice(null, videoElement, (result, error) => {
                    if (result) {
                        log('üì± Scanned code:', result.text);
                        handleScannedCode(result.text);
                    }
                    if (error && error.name !== 'NotFoundException') {
                        log('‚ùå Scanner error:', error.message);
                    }
                });
                
                isScanning = true;
                document.getElementById('startScanBtn').disabled = true;
                document.getElementById('stopScanBtn').disabled = false;
                document.getElementById('scannerStatus').innerHTML = '<p>‚úÖ Scanner active - point camera at barcode</p>';
                
            } catch (error) {
                log('‚ùå Failed to start scanner:', error.message);
                document.getElementById('scannerStatus').innerHTML = '<p>‚ùå Scanner failed: ' + error.message + '</p>';
            }
        }

        function stopScanner() {
            if (codeReader) {
                codeReader.reset();
                codeReader = null;
            }
            if (videoElement) {
                videoElement.remove();
                videoElement = null;
            }
            isScanning = false;
            document.getElementById('startScanBtn').disabled = false;
            document.getElementById('stopScanBtn').disabled = true;
            document.getElementById('scannerStatus').innerHTML = '<p>Scanner stopped</p>';
            log('üì± Scanner stopped');
        }

        async function handleScannedCode(code) {
            log('üì± Handling scanned code:', code);
            
            const cleanUPC = code.replace(/\D/g, '');
            log('üì± Clean UPC for processing:', cleanUPC);
            
            if (cleanUPC.length !== 12 && cleanUPC.length !== 13) {
                log('‚ùå Invalid UPC length:', cleanUPC.length);
                showResult('‚ùå Invalid UPC length: ' + cleanUPC.length, 'error');
                return;
            }
            
            try {
                const movieData = await lookupMovieByUPC(cleanUPC);
                
                if (movieData && movieData.title) {
                    log('‚úÖ Movie lookup successful:', movieData.title);
                    showResult(`‚úÖ Found: ${movieData.title}`, 'success');
                    
                    // Test title validation
                    if (isValidTitle(movieData.title)) {
                        log('‚úÖ Title validation passed:', movieData.title);
                        showResult(`‚úÖ Title validation: PASSED`, 'success');
                    } else {
                        log('‚ùå Title validation failed:', movieData.title);
                        showResult(`‚ùå Title validation: FAILED - "${movieData.title}"`, 'error');
                    }
                } else {
                    log('‚ùå No movie data returned');
                    showResult('‚ùå No movie data found', 'error');
                }
                
            } catch (error) {
                log('‚ùå Movie lookup failed:', error.message);
                showResult('‚ùå Lookup failed: ' + error.message, 'error');
            }
        }

        async function handleManualLookup() {
            const upc = document.getElementById('manualUPC').value.trim();
            if (!upc) {
                showResult('‚ùå Please enter a UPC', 'error');
                return;
            }
            
            log('üîç Manual UPC lookup:', upc);
            await handleScannedCode(upc);
        }

        function showResult(message, type) {
            const resultsDiv = document.getElementById('manualResults');
            const resultDiv = document.createElement('div');
            resultDiv.className = `result ${type}`;
            resultDiv.textContent = message;
            resultsDiv.appendChild(resultDiv);
            
            // Auto-scroll to bottom
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        function log(message, ...args) {
            const timestamp = new Date().toLocaleTimeString();
            const logDiv = document.getElementById('consoleLog');
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span style="color: #666;">[${timestamp}]</span> ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
            
            // Also log to console
            console.log(`[${timestamp}]`, message, ...args);
        }

        function clearLog() {
            document.getElementById('consoleLog').innerHTML = '';
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            log('üöÄ Test page loaded');
            
            document.getElementById('startScanBtn').addEventListener('click', startScanner);
            document.getElementById('stopScanBtn').addEventListener('click', stopScanner);
            document.getElementById('lookupBtn').addEventListener('click', handleManualLookup);
            document.getElementById('clearLogBtn').addEventListener('click', clearLog);
            
            // Test title validation with known bad titles
            log('üß™ Testing title validation...');
            const testTitles = [
                'Invalid component state',
                'RSonTopWFlare', 
                'ProximaNova-Reg-webfont.woff2',
                'Google Search',
                'DOCTYPE html',
                'The Matrix',
                'Inception'
            ];
            
            testTitles.forEach(title => {
                const isValid = isValidTitle(title);
                const status = isValid ? '‚úÖ VALID' : '‚ùå REJECTED';
                log(`${status}: "${title}"`);
            });
            
            log('üß™ Title validation test complete');
        });
    </script>
</body>
</html>
